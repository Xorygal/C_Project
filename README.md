Это проектный фильтр Калмана.
В своей работе он опирается на модель равноускоренного движения.
Используется эмулятор датчика, основанный на рандомайзере.
Работает для трех координат, на вход принимает только вспомогательные вещи, такие как: кол-во измерений, период измерений, разные управляющие переменные.


Подробное описание:
Используется несколько функций для работы с матрицами.

double* m_mult_a(double* A, double alpha, int M, int flag); - умножение/деление матрицы на число. Принимает матрицу, число и размерность, возвращает новую матрицу;

double* m_add(double* A, double* B, int M, int N, int sign) - сложение/вычитание матриц, в зависимости от значения int sign. Принимает матрицы, размерность и знак. Возвращает результат сложения матриц;

double* m_mult(double* A, double* B, int M, int K, int N) - умножение матрицы A (M на K) на матрицу B (K на N). В итоге получится матрица размером M на N.
Умножение происходит по принципу: строка на столбец. все элементы i-той строки м-цы A умножаются на те же по номеру элементы j-го столбца м-цы B.
Для каждой такой комбинации строка A - столбец B получается один элемент м-цы C (тут как в обычном массиве). Принимает две матрицы, их размерности, возвращает новую матрицу;

double* m_pow(double* A, int alpha, int M) - Возведение матрицы A в степень alpha. Происходит за счет вызова ф-ии m_mult. Принимает квадратную матрицу и число, возвращает результат;

double* findInvMatrix(double* matrix, int M) - не работает для общего случая, только для диагональных матриц! Находит обратную матрицу к переданной. Принимает квадратную диагональную матрицу и размерность, возвращает новую матрицу;


Эмулятор датчика и задание реальных координат:
void randomFilling(double** array, int N, int M) - заполняет массив array случайными значениями от -1000 до 1000. В первой "строке" массива лежат значения
для массива real_Coordinates (массива реальных координат). Во второй - для массива signal (датчик). Принимает двумерный массив и его размерность.;

double* findRandValue(double* R, double* start_matrix, double* rate, double** randValue, double** rand_matrix, int num, int M) - умножает значение rate[i] на
значение массива, полученного в ф-ии randomFilling под индексом [num + i]. Далее это значение приравнивается значению rand_matrix[0][i] и прибавляется к значениям переданного массива start_matrix (для массива реальных значений). rand_matirx[1] так же заполняется, но уже для значений signal и происходит по тому же принципу, но вне функции findRandValue. Принимает массив start_matrix, над которым будут проводиться операции, массив из 3-х значений rate - величина изменения start_matrix. Так же принимается двумерный массив, 
созданный в randomFilling, и индекс в этом массиве. rand_matrix - для изменения массива signal, этот массив заполняется рандомными значениями, но вычисления проводятся уже вне функции. Возвращает измененный массив start_matirx;

double* kinematicFunction(double* s_0, double* v_0, double* a_0, double M) - та самая модель движения. Тут всё происходит по формулам из физики: передаем
ускорение a_0, скорость v_0 и начальное значение s_0. Далее: s = s_0 + v_0 * t + (a*t**2)/2 - находится новое значение координаты и подается на выход.
После этого вычисления, вызывается ф-ия findRandValue, и к новому значению координаты прибавляется/отнимается случайное значение от 0 до ksi (дисперсия модели движения)


Для работы программы нужно: скачать программу gnuplot и поместить в одну папку с проектом (с файлами project.c и project.exe).
По пути: gnuplot\bin создать 9(!) текстовых файлов следующих форматов:
inX.txt, outX.txt, realX.txt

И так три раза, меняя букву перед форматом txt. Варианты : (X, Y, Z), для каждой из координат соответственно.

Если нужно запустить график вручную из программы gnuplot: plot "название файла" with lines

При каждом запуске программы результаты будут разные, т.к. используется рандомайзер

При вводе пути к программе gnuplot\bin нужно добавить \ в конце, т.е : С:\...\gnuplot\bin\
