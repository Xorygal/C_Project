Это проектный фильтр Калмана.
В своей работе он опирается на модель равноускоренного движения.
Используется эмулятор датчика, основанный на рандомайзере.
Работает для трех координат, на вход принимает только вспомогательные вещи, такие как: кол-во измерений, период измерений, разные управляющие переменные.


Подробное описание:
Используется несколько функций для работы с матрицами.

double* m_mult_a(double* A, double alpha, int M, int flag); - умножение/деление матрицы на число. Принимает матрицу, размерность, флаг (отвечает за умножение или деление) и число, возвращает новую матрицу;

double* m_add(double* A, double* B, int M, int N, int sign) - сложение/вычитание матриц, в зависимости от значения int sign. Принимает матрицы, их размерность, знак, возвращает новую матрицу;

double* m_mult(double* A, double* B, int M, int K, int N) - умножение матрицы A (M на K) на матрицу B (K на N). В итоге получится матрица размером M на N.
Умножение происходит по принципу: строка на столбец. все элементы i-той строки м-цы A умножаются на те же по номеру элементы j-го столбца м-цы B.
Для каждой такой комбинации строка A - столбец B получается один элемент м-цы C (тут как в обычном массиве). Принимает матрицы и размерность, возвращает результат умножения матриц (матрица);

double* m_pow(double* A, int alpha, int M) - Возведение матрицы A в степень alpha. Происходит за счет вызова ф-ии m_mult, принимает квадратную матрицу, число и размерность, возвращает результат вычислений, который тоже матрица;

double* findInvMatrix(double* matrix, int M) - не работает для общего случая, только для диагональных матриц! Находит обратную матрицу к переданной. Принимает квадратную матрицу, возвращает новую;


Эмулятор датчика и задание реальных координат:
void randomFilling(double** array, int N, int M) - заполняет массив array случайными значениями от -1000 до 1000. В первой "строке" массива лежат значения
для массива real_Coordinates (массива реальных координат). Во второй - для массива signal (датчик). Принимает заранее созданный двумерный массив и общую его размерность;

double* findRandValue(double* R, double* start_matrix, double* rate, double** randValue, double** rand_matrix, int num, int M) - умножает значение rate[i] на
значение массива, полученного в ф-ии randomFilling под индексом [num + i]. Далее это значение приравнивается значению rand_matrix[0][i] и прибавляется к значениям переданного массива start_matrix (для массива реальных значений). rand_matirx[1] так же заполняется, но уже для значений signal и происходит по тому же принципу, но вне функции findRandValue. Принимает матрицу, над которой выполняются действия, диагональную матрицу констант R, массив из 3-х значений rate, двумерный массив, заполненный в randomFilling, и нужный индекс в нём,
а так же двумерный массив rand_matrix на 6 элементов в сумме - с помощью него изменяется массив signal, но уже вне функции. Возвращается измененный массив start_matrix;

double* kinematicFunction(double* s_0, double* v_0, double* a_0, double M) - та самая модель движения. Тут всё происходит по формулам из физики: передаем
ускорение a_0, скорость v_0 и начальное значение s_0. Далее: s = s_0 + v_0 * t + (a*t**2)/2 - находится новое значение координаты и подается на выход.
После этого вычисления, вызывается ф-ия findRandValue, и к новому значению координаты прибавляется/отнимается случайное значение от 0 до ksi (дисперсия модели движения)


Для работы программы нужно: скачать программу gnuplot и поместить в одну папку с проектом (с файлами project.c и project.exe).
По пути: gnuplot\bin создать 9(!) текстовых файлов следующих форматов:
inX.txt, outX.txt, realX.txt

И так три раза, меняя букву перед форматом txt. Варианты : (X, Y, Z), для каждой из координат соответственно.

Если нужно запустить график вручную из программы gnuplot: plot "название файла" with lines

При каждом запуске программы результаты будут разные, т.к. используется рандомайзер

При вводе пути к программе gnuplot\bin нужно добавить \ в конце, т.е : С:\...\gnuplot\bin\
